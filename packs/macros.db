{"name":"Create Named Token","type":"script","img":"modules/plutonium/media/img/blank.png","scope":"global","command":"(async () => {\n\tconst _Api = game.modules.get(\"plutonium\").api;\n\n\tcanvas.stage.once(\"click\", async evt => {\n\t\ttry {\n\t\t\tconst {x, y} = evt.data.getLocalPosition(canvas.stage);\n\n\t\t\tconst name = await InputUiUtil.pGetUserString({title: \"Token Name\"});\n\t\t\tif (!name) return;\n\n\t\t\tconst size = await InputUiUtil.pGetUserEnum({\n\t\t\t\tvalues: Parser.SIZE_ABVS,\n\t\t\t\ttitle: \"Select Token Size\",\n\t\t\t\tfnDisplay: it => Parser.sizeAbvToFull(it),\n\t\t\t\tisResolveItem: true,\n\t\t\t});\n\t\t\tif (!size) return;\n\n\t\t\tconst {dimensions = 1, scale = 1} = _Api.util.tokens.getTokenDimensionsAndScale(size);\n\n\t\t\tawait _Api.token.pCreateToken({\n\t\t\t\tname,\n\t\t\t\txScene: x,\n\t\t\t\tyScene: y,\n\t\t\t\twidth: dimensions,\n\t\t\t\theight: dimensions,\n\t\t\t\tscale,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tui.notifications.error(`Failed to create token! ${VeCt.STR_SEE_CONSOLE}`);\n\t\t\tthrow e;\n\t\t}\n\t});\n\n\tui.notifications.info(\"Click on the canvas to spawn a token!\");\n})();\n","folder":null,"sort":0,"permission":{"default":0},"_id":"3uodczsxlchv0ao4"}
{"name":"Import to Selected Tokens","type":"script","img":"modules/plutonium/media/icon/fontawesome/atom-solid.svg","scope":"global","command":"(async () => {\n\ttry {\n\t\tconst tokens = [...canvas.tokens.controlled].filter(it => it.actor);\n\t\tif (!tokens.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);\n\n\t\tconst actors = tokens.map(it => it.actor).unique();\n\t\tif (!actors.length) return ui.notifications.warn(`Please select some tokens (which have actors) first!`);\n\n\t\t// If there is only a single actor, open the standard importer flow for this actor (as though opening it from a sheet)\n\t\tif (actors.length === 1) {\n\t\t\tawait game.modules.get(\"plutonium\").api.importer.pOpen({actor: actors[0]});\n\t\t\treturn;\n\t\t}\n\n\t\t// region If we are importing to multiple tokens, create a single dummy actor as a surrogate import target, then copy the resulting changes to each actor once the import wizard is closed.\n\t\tconst ACTOR_TYPE_PREFERENCE = [\"character\", \"npc\", \"vehicle\"];\n\t\tconst actorTypes = actors\n\t\t\t.map(it => it.type)\n\t\t\t.unique()\n\t\t\t.sort((a, b) => ACTOR_TYPE_PREFERENCE.indexOf(a) - ACTOR_TYPE_PREFERENCE.indexOf(b));\n\n\t\tif (actorTypes.length > 1) ui.notifications.warn(`Multiple actor types found in selected tokens\\u2014the importer will run as though importing to a \"${actorTypes[0]}\"-type actor.`);\n\n\t\tui.notifications.info(`You are importing to ${actors.length} actors\\u2014updates will be applied, as a batch, when the importer is closed.`);\n\n\t\tconst dummyActor = await Actor.create(\n\t\t\t{\n\t\t\t\tname: \"Temp\",\n\t\t\t\ttype: actorTypes[0],\n\t\t\t\tflags: {srd5e: {isImporterTempActor: true}},\n\t\t\t},\n\t\t\t{\n\t\t\t\trenderSheet: false,\n\t\t\t\ttemporary: true,\n\t\t\t},\n\t\t);\n\t\tconst baseData = dummyActor.toJSON();\n\t\t// Remove our temp flag, to avoid generating a junk diff later\n\t\tdelete baseData.flags.srd5e;\n\n\t\tconst importer = await game.modules.get(\"plutonium\").api.importer.pOpen({actor: dummyActor});\n\n\t\tawait game.modules.get(\"plutonium\").api.util.apps.pAwaitAppClose(importer);\n\n\t\tui.notifications.info(`Applying updates...`);\n\n\t\tconst finalData = dummyActor.toJSON();\n\n\t\t// Remove our temp flags, to avoid applying them to the target actors\n\t\tMiscUtil.delete(finalData, \"flags\", \"srd5e\", \"isImporterTempActor\");\n\t\tif (!Object.keys(MiscUtil.get(finalData, \"flags\", \"srd5e\") || {}).length) MiscUtil.delete(finalData, \"flags\", \"srd5e\");\n\n\t\tlet isAnyUpdate = false;\n\n\t\tconst DIFF_OBJECT_PROPS = [\"data\", \"token\", \"flags\"];\n\t\tfor (const prop of DIFF_OBJECT_PROPS) {\n\t\t\tif (!baseData[prop] && !finalData[prop]) continue;\n\n\t\t\tconst diff = foundry.utils.diffObject(baseData[prop], finalData[prop]);\n\n\t\t\tif (!Object.keys(diff).length) continue;\n\t\t\tisAnyUpdate = true;\n\n\t\t\tfor (const actor of actors) await actor.update({[prop]: diff});\n\t\t}\n\n\t\tconst DIFF_EMBEDDED_PROPS = [\n\t\t\t{prop: \"items\", documentName: \"Item\"},\n\t\t\t{prop: \"effects\", documentName: \"ActiveEffect\"},\n\t\t];\n\t\tfor (const {prop, documentName} of DIFF_EMBEDDED_PROPS) {\n\t\t\tif (!finalData[prop]?.length) continue;\n\t\t\tisAnyUpdate = true;\n\n\t\t\tfor (const actor of actors) {\n\t\t\t\tconst cpyEmbeds = MiscUtil.copy(finalData[prop]);\n\n\t\t\t\tconst [toCreates, toUpdates] = cpyEmbeds.segregate(embed => {\n\t\t\t\t\t// Fix any `origin`s, e.g. for active effects, which may point to invalid actors\n\t\t\t\t\tif (embed.origin && typeof embed.origin === \"string\") {\n\t\t\t\t\t\tconst originSpl = embed.origin.split(\".\");\n\t\t\t\t\t\t// E.g. `Actor.<id>.Item.<id>`\n\t\t\t\t\t\t// If the actor ID is `null`, then repair it, using our current actor's ID\n\t\t\t\t\t\tif (originSpl.length === 4 && originSpl[1] === \"null\") {\n\t\t\t\t\t\t\toriginSpl[1] = actor.id;\n\t\t\t\t\t\t\tembed.origin = originSpl.join(\".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn actor[prop].get(embed._id) == null;\n\t\t\t\t});\n\n\t\t\t\tif (toCreates.length) await actor.createEmbeddedDocuments(documentName, toCreates, {keepId: true});\n\t\t\t\tif (toUpdates.length) await actor.updateEmbeddedDocuments(documentName, toUpdates);\n\t\t\t}\n\t\t}\n\n\t\tif (isAnyUpdate) ui.notifications.info(`Updates applied!`);\n\t\telse ui.notifications.warn(`Found no updates to apply!`);\n\t\t// endregion\n\t} catch (e) {\n\t\tui.notifications.error(`Importing failed! ${VeCt.STR_SEE_CONSOLE}`);\n\t\tthrow e;\n\t}\n})();\n","folder":null,"sort":0,"permission":{"default":0},"_id":"jrv77q94idjuglaf"}